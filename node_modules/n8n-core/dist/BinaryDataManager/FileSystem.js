"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryDataFileSystem = void 0;
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_1 = require("fs");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const n8n_workflow_1 = require("n8n-workflow");
const errors_1 = require("../errors");
const PREFIX_METAFILE = 'binarymeta';
const PREFIX_PERSISTED_METAFILE = 'persistedmeta';
const executionExtractionRegexp = /^(\w+)(?:[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12})$/;
class BinaryDataFileSystem {
    constructor(config) {
        this.storagePath = config.localStoragePath;
        this.binaryDataTTL = config.binaryDataTTL;
        this.persistedBinaryDataTTL = config.persistedBinaryDataTTL;
    }
    async init(startPurger = false) {
        if (startPurger) {
            setInterval(async () => {
                await this.deleteMarkedFiles();
            }, this.binaryDataTTL * 30000);
            setInterval(async () => {
                await this.deleteMarkedPersistedFiles();
            }, this.persistedBinaryDataTTL * 30000);
        }
        await this.assertFolder(this.storagePath);
        await this.assertFolder(this.getBinaryDataMetaPath());
        await this.assertFolder(this.getBinaryDataPersistMetaPath());
        await this.deleteMarkedFiles();
        await this.deleteMarkedPersistedFiles();
    }
    async getFileSize(identifier) {
        const stats = await promises_1.default.stat(this.getBinaryPath(identifier));
        return stats.size;
    }
    async copyBinaryFile(filePath, executionId) {
        const binaryDataId = this.generateFileName(executionId);
        await this.addBinaryIdToPersistMeta(executionId, binaryDataId);
        await this.copyFileToLocalStorage(filePath, binaryDataId);
        return binaryDataId;
    }
    async storeBinaryMetadata(identifier, metadata) {
        await promises_1.default.writeFile(this.getMetadataPath(identifier), JSON.stringify(metadata), {
            encoding: 'utf-8',
        });
    }
    async getBinaryMetadata(identifier) {
        return (0, n8n_workflow_1.jsonParse)(await promises_1.default.readFile(this.getMetadataPath(identifier), { encoding: 'utf-8' }));
    }
    async storeBinaryData(binaryData, executionId) {
        const binaryDataId = this.generateFileName(executionId);
        await this.addBinaryIdToPersistMeta(executionId, binaryDataId);
        await this.saveToLocalStorage(binaryData, binaryDataId);
        return binaryDataId;
    }
    getBinaryStream(identifier, chunkSize) {
        return (0, fs_1.createReadStream)(this.getBinaryPath(identifier), { highWaterMark: chunkSize });
    }
    async retrieveBinaryDataByIdentifier(identifier) {
        return this.retrieveFromLocalStorage(identifier);
    }
    getBinaryPath(identifier) {
        return this.resolveStoragePath(identifier);
    }
    getMetadataPath(identifier) {
        return this.resolveStoragePath(`${identifier}.metadata`);
    }
    async markDataForDeletionByExecutionId(executionId) {
        const tt = new Date(new Date().getTime() + this.binaryDataTTL * 60000);
        return promises_1.default.writeFile(this.resolveStoragePath('meta', `${PREFIX_METAFILE}_${executionId}_${tt.valueOf()}`), '');
    }
    async deleteMarkedFiles() {
        return this.deleteMarkedFilesByMeta(this.getBinaryDataMetaPath(), PREFIX_METAFILE);
    }
    async deleteMarkedPersistedFiles() {
        return this.deleteMarkedFilesByMeta(this.getBinaryDataPersistMetaPath(), PREFIX_PERSISTED_METAFILE);
    }
    async addBinaryIdToPersistMeta(executionId, identifier) {
        const currentTime = new Date().getTime();
        const timeAtNextHour = currentTime + 3600000 - (currentTime % 3600000);
        const timeoutTime = timeAtNextHour + this.persistedBinaryDataTTL * 60000;
        const filePath = this.resolveStoragePath('persistMeta', `${PREFIX_PERSISTED_METAFILE}_${executionId}_${timeoutTime}`);
        try {
            await promises_1.default.access(filePath);
        }
        catch {
            await promises_1.default.writeFile(filePath, identifier);
        }
    }
    async deleteMarkedFilesByMeta(metaPath, filePrefix) {
        const currentTimeValue = new Date().valueOf();
        const metaFileNames = await (0, fast_glob_1.default)(`${filePrefix}_*`, { cwd: metaPath });
        const executionIds = metaFileNames
            .map((f) => f.split('_'))
            .filter(([prefix, , ts]) => {
            if (prefix !== filePrefix)
                return false;
            const execTimestamp = parseInt(ts, 10);
            return execTimestamp < currentTimeValue;
        })
            .map((e) => e[1]);
        const filesToDelete = [];
        const deletedIds = await this.deleteBinaryDataByExecutionIds(executionIds);
        for (const executionId of deletedIds) {
            filesToDelete.push(...(await (0, fast_glob_1.default)(`${filePrefix}_${executionId}_`, {
                absolute: true,
                cwd: metaPath,
            })));
        }
        await Promise.all(filesToDelete.map(async (file) => promises_1.default.rm(file)));
    }
    async duplicateBinaryDataByIdentifier(binaryDataId, prefix) {
        const newBinaryDataId = this.generateFileName(prefix);
        await promises_1.default.copyFile(this.resolveStoragePath(binaryDataId), this.resolveStoragePath(newBinaryDataId));
        return newBinaryDataId;
    }
    async deleteBinaryDataByExecutionIds(executionIds) {
        var _a;
        const set = new Set(executionIds);
        const fileNames = await promises_1.default.readdir(this.storagePath);
        const deletedIds = [];
        for (const fileName of fileNames) {
            const executionId = (_a = fileName.match(executionExtractionRegexp)) === null || _a === void 0 ? void 0 : _a[1];
            if (executionId && set.has(executionId)) {
                const filePath = this.resolveStoragePath(fileName);
                await Promise.all([promises_1.default.rm(filePath), promises_1.default.rm(`${filePath}.metadata`)]);
                deletedIds.push(executionId);
            }
        }
        return deletedIds;
    }
    async deleteBinaryDataByIdentifier(identifier) {
        return this.deleteFromLocalStorage(identifier);
    }
    async persistBinaryDataForExecutionId(executionId) {
        const metaFiles = await promises_1.default.readdir(this.getBinaryDataPersistMetaPath());
        const promises = metaFiles.reduce((prev, curr) => {
            if (curr.startsWith(`${PREFIX_PERSISTED_METAFILE}_${executionId}_`)) {
                prev.push(promises_1.default.rm(path_1.default.join(this.getBinaryDataPersistMetaPath(), curr)));
                return prev;
            }
            return prev;
        }, []);
        await Promise.all(promises);
    }
    async assertFolder(folder) {
        try {
            await promises_1.default.access(folder);
        }
        catch {
            await promises_1.default.mkdir(folder, { recursive: true });
        }
    }
    generateFileName(prefix) {
        return [prefix, (0, uuid_1.v4)()].join('');
    }
    getBinaryDataMetaPath() {
        return path_1.default.join(this.storagePath, 'meta');
    }
    getBinaryDataPersistMetaPath() {
        return path_1.default.join(this.storagePath, 'persistMeta');
    }
    async deleteFromLocalStorage(identifier) {
        return promises_1.default.rm(this.getBinaryPath(identifier));
    }
    async copyFileToLocalStorage(source, identifier) {
        await promises_1.default.cp(source, this.getBinaryPath(identifier));
    }
    async saveToLocalStorage(binaryData, identifier) {
        await promises_1.default.writeFile(this.getBinaryPath(identifier), binaryData);
    }
    async retrieveFromLocalStorage(identifier) {
        const filePath = this.getBinaryPath(identifier);
        try {
            return await promises_1.default.readFile(filePath);
        }
        catch (e) {
            throw new Error(`Error finding file: ${filePath}`);
        }
    }
    resolveStoragePath(...args) {
        const returnPath = path_1.default.join(this.storagePath, ...args);
        if (path_1.default.relative(this.storagePath, returnPath).startsWith('..'))
            throw new errors_1.FileNotFoundError('Invalid path detected');
        return returnPath;
    }
}
exports.BinaryDataFileSystem = BinaryDataFileSystem;
//# sourceMappingURL=FileSystem.js.map